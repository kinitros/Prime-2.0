-- Create webhooks table
CREATE TABLE IF NOT EXISTS webhooks (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  url TEXT NOT NULL,
  events JSONB NOT NULL DEFAULT '[]',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS for webhooks
ALTER TABLE webhooks ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any
DROP POLICY IF EXISTS "Admin full access for webhooks" ON webhooks;

-- Create policy for admin access
CREATE POLICY "Admin full access for webhooks" 
ON webhooks FOR ALL 
TO authenticated 
USING (true) 
WITH CHECK (true);

-- Grant permissions
GRANT ALL ON webhooks TO authenticated;

-- Ensure orders table has a sequential ID if it doesn't already
-- We try to add a column 'seq_id' if 'id' is already taken by something else or not suitable.
-- However, typically 'id' is the PK. Let's check if we can add a serial column.
-- Since we can't easily check schema, we'll try to add a column 'friendly_id' 
-- that is auto-incrementing.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'orders' AND column_name = 'friendly_id') THEN
        ALTER TABLE orders ADD COLUMN friendly_id BIGINT GENERATED BY DEFAULT AS IDENTITY;
    END IF;
END $$;

-- If friendly_id was just added, it might be null for existing rows. 
-- We can populate it, but preserving strict 1,2,3 order for existing rows is hard without re-creating.
-- For now, let's assume new orders will get it. 
-- To backfill:
-- WITH numbered AS (
--   SELECT id, ROW_NUMBER() OVER (ORDER BY created_at) as rn
--   FROM orders
-- )
-- UPDATE orders o
-- SET friendly_id = n.rn
-- FROM numbered n
-- WHERE o.id = n.id AND o.friendly_id IS NULL;
